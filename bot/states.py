import re
import logging
import requests
import aiohttp
from dataclasses import dataclass
from datetime import datetime, timedelta
from dateparser.search import search_dates

from abc import ABC, abstractmethod
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext

logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def parse_datetime(text):
    """
    –ü–∞—Ä—Å–∏—Ç –¥–∞—Ç—É –∏–∑ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–º–æ—â—å—é dateparser.
    –ï—Å–ª–∏ –≤ —Ç–µ–∫—Å—Ç–µ –µ—Å—Ç—å –≤—Ä–µ–º—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 'YYYY-MM-DD HH:MM', –∏–Ω–∞—á–µ 'YYYY-MM-DD'
    """
    parsed_date = search_dates(text, languages=["ru"])
    pattern_time = re.search(r'\d\d:\d\d', text)

    if not parsed_date:
        return None
    
    date = parsed_date[0][1].strftime("%Y-%m-%d %H:%M") if pattern_time is not None \
            else parsed_date[0][1].strftime("%Y-%m-%d")
    
    return date


def event_or_todo(date):
    # 1 - todo; 0 - event
    return bool(re.search(r'\d\d:\d\d', date))


class BotState(ABC):
    @abstractmethod
    async def handle(self, bot, update, context):
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –¥–∞–Ω–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏.
        :param bot: —ç–∫–∑–µ–º–ø–ª—è—Ä –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–ª–∞—Å—Å–∞ –±–æ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, TelegramCalendarBot)
        :param update: –æ–±—ä–µ–∫—Ç Update
        :param context: CallbackContext
        """
        pass


# –°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ–∂–∏–¥–∞–Ω–∏–µ –≤–≤–æ–¥–∞ –¥–∞—Ç—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è
class AwaitingEventDateState(BotState):
    async def handle(self, bot, update, context):
        user_id = update.effective_user.id
        text = update.message.text
        date = parse_datetime(text)
        if date is None:
            logger.warning(f"User {user_id} sent invalid date: {text}")
            await update.message.reply_text("–ù–µ –ø–æ–Ω—è–ª –¥–∞—Ç—É ü•≤. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑")
            return
        context.user_data["temp_date"] = date
        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é ‚Äì –≤–≤–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è
        context.user_data["state"] = "awaiting_event_name"
        await update.message.reply_text("‚úçÔ∏è –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è")


# –°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ–∂–∏–¥–∞–Ω–∏–µ –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è
class AwaitingEventNameState(BotState):
    async def handle(self, bot, update, context):
        user_id = update.effective_user.id
        event_name = update.message.text
        temp_date = context.user_data.get("temp_date")
        if not temp_date:
            await update.message.reply_text("–î–∞—Ç–∞ –ø–æ—Ç–µ—Ä—è–ª–∞—Å—å ü•≤, –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞")
            return

        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
        url = f"{bot.backend_url}/todos" if event_or_todo(temp_date) else f"{bot.backend_url}/events"
        payload = {"user_id": user_id, "name": event_name, "date": temp_date}
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=payload) as resp:
                if resp.status in {200, 201}:
                    logger.info(f"User {user_id} successfully added event: {event_name} on {temp_date}")
                    await update.message.reply_text(f"–°–æ–±—ã—Ç–∏–µ '{event_name}' –∑–∞–ø–∏—Å–∞–Ω–æ –Ω–∞ {temp_date}!")
                else:
                    logger.error(f"User {user_id} failed to add event: {event_name} ({temp_date}). Status: {resp.status}")
                    await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–æ–±—ã—Ç–∏—è üõ†Ô∏è")

        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        context.user_data["state"] = None
        context.user_data.pop("temp_date", None)


# –°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ–∂–∏–¥–∞–Ω–∏–µ –≤–≤–æ–¥–∞ –¥–∞—Ç—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏—è/–∑–∞–º–µ—Ç–∫–∏
class AwaitingDeleteDateState(BotState):
    async def handle(self, bot, update, context):
        user_id = update.effective_user.id
        text = update.message.text
        date = parse_datetime(text)
        if date is None:
            logger.warning(f"User {user_id} sent invalid date: {text}")
            await update.message.reply_text("–ù–µ –ø–æ–Ω—è–ª –¥–∞—Ç—É ü•≤. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑")
            return
        context.user_data["temp_date"] = date

        # –ü–æ–ª—É—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è –Ω–∞ –¥–∞–Ω–Ω—É—é –¥–∞—Ç—É —á–µ—Ä–µ–∑ backend API
        response = await bot.fetch_events_by_date(user_id, date)
        if response is None or not response:
            await update.message.reply_text("–ù–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–∏—á–µ–≥–æ –Ω–µ—Ç üòå")
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            context.user_data["state"] = None
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        events_mapping = {str(i + 1): event["name"] for i, event in enumerate(response)}
        context.user_data["delete_events"] = events_mapping
        events_list = "\n".join(f"{i+1}. {name}" for i, name in events_mapping.items())
        await update.message.reply_text(f"üìÖ –°–æ–±—ã—Ç–∏—è –Ω–∞ {date}:\n–í—ã–±–µ—Ä–∏ –Ω–æ–º–µ—Ä —Å–æ–±—ã—Ç–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:\n{events_list}")

        context.user_data["state"] = "awaiting_delete_choice"